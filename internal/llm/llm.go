package llm

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/biswajitpain/gitter/internal/config"
	"net/http"
	"time"
)

// LLMClient is the interface for a client that can generate commit messages.
type LLMClient interface {
	GenerateCommitMessage(diff string, userMessage string) (string, error)
}

// NewLLMClient returns an LLM client based on the provided config.
func NewLLMClient(cfg config.Config) (LLMClient, error) {
	switch cfg.Provider {
	case "openai":
		return &OpenAIClient{
			APIKey:  cfg.APIKey,
			BaseURL: "https://api.openai.com/v1",
		}, nil
	case "gemini":
		if cfg.APIKey == "" {
			return nil, fmt.Errorf("Gemini API key is not set in config")
		}
		return &GeminiClient{
			APIKey: cfg.APIKey,
		}, nil

	case "":
		return nil, fmt.Errorf("no LLM provider configured")
	default:
		return nil, fmt.Errorf("unsupported LLM provider: %s", cfg.Provider)
	}
}

// OpenAIClient is a client for the OpenAI API.
type OpenAIClient struct {
	APIKey  string
	BaseURL string
}

// openAIRequest represents the request body for the OpenAI text completion API.
type openAIRequest struct {
	Model string `json:"model"`
	Input string `json:"input"`
}

// openAIResponse is the response from the OpenAI API.
type openAIResponse struct {
	OutputText string `json:"output_text"`
	Error      *struct {
		Message string `json:"message"`
	} `json:"error,omitempty"`
}

// GenerateCommitMessage generates a commit message using the OpenAI API.
func (c *OpenAIClient) GenerateCommitMessage(diff string, userMessage string) (string, error) {
	if c.APIKey == "" {
		return "", fmt.Errorf("OpenAI API key is not set")
	}

	prompt := fmt.Sprintf(`You are an expert at writing conventional git commit messages.
Based on the following user prompt and git diff, generate a concise and descriptive commit message.
The message should follow the conventional commit format (e.g., 'feat: add new feature' or 'fix: resolve a bug').
The first line should be a short summary (the title), followed by a blank line, and then a more detailed description (the body) if necessary.
Do not include the 'Changes:' section with file stats in your output.

User Prompt: "%s"

Git Diff:
%s`, userMessage, diff)

	reqBody := openAIRequest{
		Model: "gpt-4.1", // Using gpt-4.1 as specified by the user's curl command
		Input: prompt,
	}

	reqBytes, err := json.Marshal(reqBody)
	if err != nil {
		return "", fmt.Errorf("could not marshal OpenAI request: %w", err)
	}

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	requestURL := fmt.Sprintf("%s/responses", c.BaseURL) // Endpoint changed to /responses
	req, err := http.NewRequestWithContext(ctx, "POST", requestURL, bytes.NewBuffer(reqBytes))
	if err != nil {
		return "", fmt.Errorf("could not create OpenAI request: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+c.APIKey)

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("could not send request to OpenAI: %w", err)
	}
	defer resp.Body.Close()

	var apiResp openAIResponse
	if err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {
		return "", fmt.Errorf("could not decode OpenAI response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		if apiResp.Error != nil {
			return "", fmt.Errorf("OpenAI API error (%s): %s", resp.Status, apiResp.Error.Message)
		}
		return "", fmt.Errorf("OpenAI API request failed with status: %s", resp.Status)
	}

	if apiResp.OutputText == "" {
		return "", fmt.Errorf("no commit message generated by OpenAI")
	}

	return apiResp.OutputText, nil
}

// GeminiClient is a client for the Gemini API.
type GeminiClient struct {
	APIKey string
}

// geminiRequest represents the request body for the Gemini generateContent API.
type geminiRequest struct {
	Contents []struct {
		Parts []struct {
			Text string `json:"text"`
		} `json:"parts"`
	} `json:"contents"`
}

// geminiResponse is the response from the Gemini generateContent API.
type geminiResponse struct {
	Candidates []struct {
		Content struct {
			Parts []struct {
				Text string `json:"text"`
			} `json:"parts"`
		} `json:"content"`
	} `json:"candidates"`
	// Assuming other fields like usageMetadata, modelVersion, etc., are not needed for extraction
	Error *struct {
		Message string `json:"message"`
	} `json:"error,omitempty"`
}

// GenerateCommitMessage generates a commit message using the Gemini API.
func (c *GeminiClient) GenerateCommitMessage(diff, userMessage string) (string, error) {
	if c.APIKey == "" {
		return "", fmt.Errorf("Gemini API key is not set")
	}

	prompt := fmt.Sprintf(`You are an expert at writing conventional git commit messages.
Based on the following user prompt and git diff, generate a concise and descriptive commit message.
The message should follow the conventional commit format (e.g., 'feat: add new feature' or 'fix: resolve a bug').
The first line should be a short summary (the title), followed by a blank line, and then a more detailed description (the body) if necessary.
Do not include the 'Changes:' section with file stats in your output.

User Prompt: "%s"

Git Diff:
%s`, userMessage, diff)

	reqBody := geminiRequest{
		Contents: []struct {
			Parts []struct {
				Text string `json:"text"`
			} `json:"parts"`
		}{
			{
				Parts: []struct {
					Text string `json:"text"`
				}{
					{Text: prompt},
				},
			},
		},
	}

	reqBytes, err := json.Marshal(reqBody)
	if err != nil {
		return "", fmt.Errorf("could not marshal Gemini request: %w", err)
	}

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	requestURL := "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent"
	req, err := http.NewRequestWithContext(ctx, "POST", requestURL, bytes.NewBuffer(reqBytes))
	if err != nil {
		return "", fmt.Errorf("could not create Gemini request: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("x-goog-api-key", c.APIKey) // API key in custom header

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("could not send request to Gemini API: %w", err)
	}
	defer resp.Body.Close()

	var apiResp geminiResponse
	if err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {
		return "", fmt.Errorf("could not decode Gemini response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		if apiResp.Error != nil {
			return "", fmt.Errorf("Gemini API error (%s): %s", resp.Status, apiResp.Error.Message)
		}
		return "", fmt.Errorf("Gemini API request failed with status: %s", resp.Status)
	}

	if len(apiResp.Candidates) == 0 || len(apiResp.Candidates[0].Content.Parts) == 0 || apiResp.Candidates[0].Content.Parts[0].Text == "" {
		return "", fmt.Errorf("no commit message generated by Gemini")
	}

	return apiResp.Candidates[0].Content.Parts[0].Text, nil
}
